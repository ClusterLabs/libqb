<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>libqb: qbrb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libqb
   &#160;<span id="projectnumber">0.16.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_99176029e6245da7be482686d42cbcde.html">qb</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">qbrb.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This implements a ring buffer that works in "chunks" not bytes.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for qbrb.h:</div>
<div class="dyncontent">
<div class="center"><img src="qbrb_8h__incl.png" border="0" usemap="#qbrb_8h" alt=""/></div>
<map name="qbrb_8h" id="qbrb_8h">
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3bf2613790c34f1da4da7e5d28b9f418"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a3bf2613790c34f1da4da7e5d28b9f418">QB_RB_FLAG_CREATE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:a3bf2613790c34f1da4da7e5d28b9f418"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a ring buffer (rather than open and existing one)  <a href="#a3bf2613790c34f1da4da7e5d28b9f418"></a><br/></td></tr>
<tr class="separator:a3bf2613790c34f1da4da7e5d28b9f418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1857ecabb97a65d157bbc5ccaa536d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ac1857ecabb97a65d157bbc5ccaa536d9">QB_RB_FLAG_OVERWRITE</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ac1857ecabb97a65d157bbc5ccaa536d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">New calls to <a class="el" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121" title="Write a chunk to the ring buffer.">qb_rb_chunk_write()</a> will call <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a> if there is not enough space.  <a href="#ac1857ecabb97a65d157bbc5ccaa536d9"></a><br/></td></tr>
<tr class="separator:ac1857ecabb97a65d157bbc5ccaa536d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb866bfc44855b73e4404f6526ce5ad"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#afdb866bfc44855b73e4404f6526ce5ad">QB_RB_FLAG_SHARED_THREAD</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="memdesc:afdb866bfc44855b73e4404f6526ce5ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ringbuffer will be shared between pthreads not processes.  <a href="#afdb866bfc44855b73e4404f6526ce5ad"></a><br/></td></tr>
<tr class="separator:afdb866bfc44855b73e4404f6526ce5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac893c2640e8291e6229a227a861c760c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c">QB_RB_FLAG_SHARED_PROCESS</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="memdesc:ac893c2640e8291e6229a227a861c760c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ringbuffer will be shared between processes.  <a href="#ac893c2640e8291e6229a227a861c760c"></a><br/></td></tr>
<tr class="separator:ac893c2640e8291e6229a227a861c760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9796b3ce0f4ea6fd710697058bb87c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a2a9796b3ce0f4ea6fd710697058bb87c">QB_RB_FLAG_NO_SEMAPHORE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a2a9796b3ce0f4ea6fd710697058bb87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't use semaphores, only atomic ops.  <a href="#a2a9796b3ce0f4ea6fd710697058bb87c"></a><br/></td></tr>
<tr class="separator:a2a9796b3ce0f4ea6fd710697058bb87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa73b885fa2fbda5dfe4f374e4e0ae0da"><td class="memItemLeft" align="right" valign="top">typedef struct qb_ringbuffer_s&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a></td></tr>
<tr class="separator:aa73b885fa2fbda5dfe4f374e4e0ae0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad7f0ee52204d491ddb6c5adf88e38c31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31">qb_rb_open</a> (const char *name, size_t size, uint32_t flags, size_t shared_user_data_size)</td></tr>
<tr class="memdesc:ad7f0ee52204d491ddb6c5adf88e38c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the ring buffer with the given type.  <a href="#ad7f0ee52204d491ddb6c5adf88e38c31"></a><br/></td></tr>
<tr class="separator:ad7f0ee52204d491ddb6c5adf88e38c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676646fa5f7d2dba585a92b99f91a84c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a676646fa5f7d2dba585a92b99f91a84c">qb_rb_close</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:a676646fa5f7d2dba585a92b99f91a84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereference the ringbuffer and if we are the last user destroy it.  <a href="#a676646fa5f7d2dba585a92b99f91a84c"></a><br/></td></tr>
<tr class="separator:a676646fa5f7d2dba585a92b99f91a84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedda1312afff053ccbfddbd074351641"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aedda1312afff053ccbfddbd074351641">qb_rb_name_get</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:aedda1312afff053ccbfddbd074351641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the ringbuffer.  <a href="#aedda1312afff053ccbfddbd074351641"></a><br/></td></tr>
<tr class="separator:aedda1312afff053ccbfddbd074351641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18f8ca651e8ef29b43a311e280aee37"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aa18f8ca651e8ef29b43a311e280aee37">qb_rb_shared_user_data_get</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:aa18f8ca651e8ef29b43a311e280aee37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a point to user shared data area.  <a href="#aa18f8ca651e8ef29b43a311e280aee37"></a><br/></td></tr>
<tr class="separator:aa18f8ca651e8ef29b43a311e280aee37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be2cb75d70f5befe605501721086121"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121">qb_rb_chunk_write</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, const void *data, size_t len)</td></tr>
<tr class="memdesc:a6be2cb75d70f5befe605501721086121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a chunk to the ring buffer.  <a href="#a6be2cb75d70f5befe605501721086121"></a><br/></td></tr>
<tr class="separator:a6be2cb75d70f5befe605501721086121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e73503e8dc50e3cad1022bb740ef6c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c">qb_rb_chunk_alloc</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, size_t len)</td></tr>
<tr class="memdesc:ae0e73503e8dc50e3cad1022bb740ef6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for a chunk of the given size.  <a href="#ae0e73503e8dc50e3cad1022bb740ef6c"></a><br/></td></tr>
<tr class="separator:ae0e73503e8dc50e3cad1022bb740ef6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be62e0deea17d91292e2a84f6d864b9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a0be62e0deea17d91292e2a84f6d864b9">qb_rb_chunk_commit</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, size_t len)</td></tr>
<tr class="memdesc:a0be62e0deea17d91292e2a84f6d864b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">finalize the chunk.  <a href="#a0be62e0deea17d91292e2a84f6d864b9"></a><br/></td></tr>
<tr class="separator:a0be62e0deea17d91292e2a84f6d864b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec633cc7fee08c5c73445fab3edc9d44"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aec633cc7fee08c5c73445fab3edc9d44">qb_rb_chunk_peek</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, void **data_out, int32_t ms_timeout)</td></tr>
<tr class="memdesc:aec633cc7fee08c5c73445fab3edc9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read (without reclaiming) the last chunk.  <a href="#aec633cc7fee08c5c73445fab3edc9d44"></a><br/></td></tr>
<tr class="separator:aec633cc7fee08c5c73445fab3edc9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4e369c61625edfad2bda86165725c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0">qb_rb_chunk_reclaim</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:aea4e369c61625edfad2bda86165725c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reclaim the oldest chunk.  <a href="#aea4e369c61625edfad2bda86165725c0"></a><br/></td></tr>
<tr class="separator:aea4e369c61625edfad2bda86165725c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb042cad040e561093604ce5050f85b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aaeb042cad040e561093604ce5050f85b">qb_rb_chunk_read</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, void *data_out, size_t len, int32_t ms_timeout)</td></tr>
<tr class="memdesc:aaeb042cad040e561093604ce5050f85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the oldest chunk into data_out.  <a href="#aaeb042cad040e561093604ce5050f85b"></a><br/></td></tr>
<tr class="separator:aaeb042cad040e561093604ce5050f85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1712513305a610df664f0b8a382d95"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#abe1712513305a610df664f0b8a382d95">qb_rb_refcount_get</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:abe1712513305a610df664f0b8a382d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="#abe1712513305a610df664f0b8a382d95"></a><br/></td></tr>
<tr class="separator:abe1712513305a610df664f0b8a382d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6b26f1c15cbd4050a9487e4399757c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a0e6b26f1c15cbd4050a9487e4399757c">qb_rb_space_free</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:a0e6b26f1c15cbd4050a9487e4399757c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of free space in the ring buffer.  <a href="#a0e6b26f1c15cbd4050a9487e4399757c"></a><br/></td></tr>
<tr class="separator:a0e6b26f1c15cbd4050a9487e4399757c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aec2cca1b640d73c35efdcb545225f9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a3aec2cca1b640d73c35efdcb545225f9">qb_rb_space_used</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:a3aec2cca1b640d73c35efdcb545225f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total amount of data in the buffer.  <a href="#a3aec2cca1b640d73c35efdcb545225f9"></a><br/></td></tr>
<tr class="separator:a3aec2cca1b640d73c35efdcb545225f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961e46671f346f94fefa0690a12a9d71"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a961e46671f346f94fefa0690a12a9d71">qb_rb_chunks_used</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr class="memdesc:a961e46671f346f94fefa0690a12a9d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The total number of chunks in the buffer.  <a href="#a961e46671f346f94fefa0690a12a9d71"></a><br/></td></tr>
<tr class="separator:a961e46671f346f94fefa0690a12a9d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a05bc0ced76b97f38be38bfd4ee19f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a53a05bc0ced76b97f38be38bfd4ee19f">qb_rb_write_to_file</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, int32_t fd)</td></tr>
<tr class="memdesc:a53a05bc0ced76b97f38be38bfd4ee19f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of the Ring Buffer to file.  <a href="#a53a05bc0ced76b97f38be38bfd4ee19f"></a><br/></td></tr>
<tr class="separator:a53a05bc0ced76b97f38be38bfd4ee19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaccf9973a435866fcddd937a2ad8f90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aeaccf9973a435866fcddd937a2ad8f90">qb_rb_create_from_file</a> (int32_t fd, uint32_t flags)</td></tr>
<tr class="memdesc:aeaccf9973a435866fcddd937a2ad8f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the saved ring buffer from file into tempory memory.  <a href="#aeaccf9973a435866fcddd937a2ad8f90"></a><br/></td></tr>
<tr class="separator:aeaccf9973a435866fcddd937a2ad8f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6266e10354c068267cf33ef349ceffb7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a6266e10354c068267cf33ef349ceffb7">qb_rb_chown</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, uid_t owner, gid_t group)</td></tr>
<tr class="memdesc:a6266e10354c068267cf33ef349ceffb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like 'chown' it changes the owner and group of the ringbuffers resources.  <a href="#a6266e10354c068267cf33ef349ceffb7"></a><br/></td></tr>
<tr class="separator:a6266e10354c068267cf33ef349ceffb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb8a90e13ee826b60c93a4b5bbecc64"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a8cb8a90e13ee826b60c93a4b5bbecc64">qb_rb_chmod</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, mode_t mode)</td></tr>
<tr class="memdesc:a8cb8a90e13ee826b60c93a4b5bbecc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like 'chmod' it changes the mode of the ringbuffers resources.  <a href="#a8cb8a90e13ee826b60c93a4b5bbecc64"></a><br/></td></tr>
<tr class="separator:a8cb8a90e13ee826b60c93a4b5bbecc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This implements a ring buffer that works in "chunks" not bytes. </p>
<p>So you write/read a complete chunk or not at all. There are two types of ring buffer normal and overwrite. Overwrite will reclaim the oldest chunks inorder to make way for new ones, the normal version will refuse to write a new chunk if the ring buffer is full.</p>
<p>This implementation is capable of working across processes, but one process must only write and the other prrocess read.</p>
<p>The read process will do the following: </p>
<div class="fragment"><div class="line">rb = <a class="code" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open</a>(<span class="stringliteral">&quot;test2&quot;</span>, 2000, <a class="code" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c" title="The ringbuffer will be shared between processes.">QB_RB_FLAG_SHARED_PROCESS</a>|<a class="code" href="qbrb_8h.html#a3bf2613790c34f1da4da7e5d28b9f418" title="create a ring buffer (rather than open and existing one)">QB_RB_FLAG_CREATE</a>);</div>
<div class="line"><span class="keywordflow">for</span> (i = 0; i &lt; 200; i++) {</div>
<div class="line">try_read_again:</div>
<div class="line">   l = <a class="code" href="qbrb_8h.html#aaeb042cad040e561093604ce5050f85b" title="Read the oldest chunk into data_out.">qb_rb_chunk_read</a>(rb, (<span class="keywordtype">void</span> *)out, 32, 1000);</div>
<div class="line">   <span class="keywordflow">if</span> (l &lt; 0) {</div>
<div class="line">           <span class="keywordflow">goto</span> try_read_again;</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">qb_rb_close(rb);</div>
</div><!-- fragment --><p>The write process will do the following: </p>
<div class="fragment"><div class="line">     rb = <a class="code" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open</a>(<span class="stringliteral">&quot;test2&quot;</span>, 2000, <a class="code" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c" title="The ringbuffer will be shared between processes.">QB_RB_FLAG_SHARED_PROCESS</a>);</div>
<div class="line">     <span class="keywordflow">for</span> (i = 0; i &lt; 200; i++) {</div>
<div class="line">try_write_again:</div>
<div class="line">        l = <a class="code" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121" title="Write a chunk to the ring buffer.">qb_rb_chunk_write</a>(rb, &amp;v, <span class="keyword">sizeof</span>(v));</div>
<div class="line">        <span class="keywordflow">if</span> (l &lt; <span class="keyword">sizeof</span>(v)) {</div>
<div class="line">                <span class="keywordflow">goto</span> try_write_again;</div>
<div class="line">        }</div>
<div class="line">     }</div>
<div class="line">     ...</div>
<div class="line">     <a class="code" href="qbrb_8h.html#a676646fa5f7d2dba585a92b99f91a84c" title="Dereference the ringbuffer and if we are the last user destroy it.">qb_rb_close</a>(rb);</div>
</div><!-- fragment --><dl class="section author"><dt>Author</dt><dd>Angus Salkeld <a href="#" onclick="location.href='mai'+'lto:'+'asa'+'lk'+'eld'+'@r'+'edh'+'at'+'.co'+'m'; return false;">asalk<span style="display: none;">.nosp@m.</span>eld@<span style="display: none;">.nosp@m.</span>redha<span style="display: none;">.nosp@m.</span>t.co<span style="display: none;">.nosp@m.</span>m</a> </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3bf2613790c34f1da4da7e5d28b9f418"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_CREATE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a ring buffer (rather than open and existing one) </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2a9796b3ce0f4ea6fd710697058bb87c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_NO_SEMAPHORE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't use semaphores, only atomic ops. </p>
<p>This mean that the timeout passed into <a class="el" href="qbrb_8h.html#aaeb042cad040e561093604ce5050f85b" title="Read the oldest chunk into data_out.">qb_rb_chunk_read()</a> will be ignored. </p>

</div>
</div>
<a class="anchor" id="ac1857ecabb97a65d157bbc5ccaa536d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_OVERWRITE&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>New calls to <a class="el" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121" title="Write a chunk to the ring buffer.">qb_rb_chunk_write()</a> will call <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a> if there is not enough space. </p>
<p>If this is not set then new writes will be refused. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac893c2640e8291e6229a227a861c760c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_SHARED_PROCESS&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ringbuffer will be shared between processes. </p>
<p>This effects the type of locks/semaphores that are used. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afdb866bfc44855b73e4404f6526ce5ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_SHARED_THREAD&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ringbuffer will be shared between pthreads not processes. </p>
<p>This effects the type of locks/semaphores that are used. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aa73b885fa2fbda5dfe4f374e4e0ae0da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct qb_ringbuffer_s <a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8cb8a90e13ee826b60c93a4b5bbecc64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_chmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like 'chmod' it changes the mode of the ringbuffers resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>mode to change to </td></tr>
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>== ok </td></tr>
    <tr><td class="paramname">-errno</td><td>for error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6266e10354c068267cf33ef349ceffb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_chown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like 'chown' it changes the owner and group of the ringbuffers resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>uid of the owner to change to </td></tr>
    <tr><td class="paramname">group</td><td>gid of the group to change to </td></tr>
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status (0 = ok, -errno for error) </dd></dl>

</div>
</div>
<a class="anchor" id="ae0e73503e8dc50e3cad1022bb740ef6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* qb_rb_chunk_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate space for a chunk of the given size. </p>
<p>If type == QB_RB_FLAG_OVERWRITE then this will always return non-null but if it's type is QB_RB_NORMAL then when there is not enough space then it will return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
    <tr><td class="paramname">len</td><td>(in) the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to chunk to write to, or NULL (if no space).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c" title="Allocate space for a chunk of the given size.">qb_rb_chunk_alloc()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0be62e0deea17d91292e2a84f6d864b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_chunk_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finalize the chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
    <tr><td class="paramname">len</td><td>(in) the size of the chunk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec633cc7fee08c5c73445fab3edc9d44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunk_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ms_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read (without reclaiming) the last chunk. </p>
<p>This function is a way of accessing the next chunk without a memcpy(). You can read the chunk data in place.</p>
<dl class="section note"><dt>Note</dt><dd>This function will not "pop" the chunk, you will need to call <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
    <tr><td class="paramname">data_out</td><td>(out) a pointer to the next chunk to read (not copied). </td></tr>
    <tr><td class="paramname">ms_timeout</td><td>(in) time to wait for new data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the chunk (0 if buffer empty). </dd></dl>

</div>
</div>
<a class="anchor" id="aaeb042cad040e561093604ce5050f85b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunk_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>ms_timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the oldest chunk into data_out. </p>
<p>This is the same as <a class="el" href="qbrb_8h.html#aec633cc7fee08c5c73445fab3edc9d44" title="Read (without reclaiming) the last chunk.">qb_rb_chunk_peek()</a> memcpy() and <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
    <tr><td class="paramname">data_out</td><td>(in/out) the chunk will be memcpy'ed into this. </td></tr>
    <tr><td class="paramname">len</td><td>(in) the size of data_out. </td></tr>
    <tr><td class="paramname">ms_timeout</td><td>the amount od time to wait for new data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the chunk, or error. </dd></dl>

</div>
</div>
<a class="anchor" id="aea4e369c61625edfad2bda86165725c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qb_rb_chunk_reclaim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reclaim the oldest chunk. </p>
<p>You will need to call this if using <a class="el" href="qbrb_8h.html#aec633cc7fee08c5c73445fab3edc9d44" title="Read (without reclaiming) the last chunk.">qb_rb_chunk_peek()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6be2cb75d70f5befe605501721086121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunk_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a chunk to the ring buffer. </p>
<p>This simply calls <a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c" title="Allocate space for a chunk of the given size.">qb_rb_chunk_alloc()</a> and then <a class="el" href="qbrb_8h.html#a0be62e0deea17d91292e2a84f6d864b9" title="finalize the chunk.">qb_rb_chunk_commit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
    <tr><td class="paramname">data</td><td>(in) the data to write </td></tr>
    <tr><td class="paramname">len</td><td>(in) the size of the chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the amount of bytes actually buffered (either len or -1).</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c" title="Allocate space for a chunk of the given size.">qb_rb_chunk_alloc()</a> </dd>
<dd>
<a class="el" href="qbrb_8h.html#a0be62e0deea17d91292e2a84f6d864b9" title="finalize the chunk.">qb_rb_chunk_commit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a961e46671f346f94fefa0690a12a9d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunks_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total number of chunks in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a676646fa5f7d2dba585a92b99f91a84c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qb_rb_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dereference the ringbuffer and if we are the last user destroy it. </p>
<p>All files, mmaped memory, semaphores and locks will be destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeaccf9973a435866fcddd937a2ad8f90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a>* qb_rb_create_from_file </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the saved ring buffer from file into tempory memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>file with saved ringbuffer data. </td></tr>
    <tr><td class="paramname">flags</td><td>same flags as passed into <a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new ringbuffer instance </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#a53a05bc0ced76b97f38be38bfd4ee19f" title="Write the contents of the Ring Buffer to file.">qb_rb_write_to_file()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aedda1312afff053ccbfddbd074351641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* qb_rb_name_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of the ringbuffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7f0ee52204d491ddb6c5adf88e38c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a>* qb_rb_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>shared_user_data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the ring buffer with the given type. </p>
<p>This creates allocates a ring buffer in shared memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the unique name of this ringbuffer. </td></tr>
    <tr><td class="paramname">size</td><td>the requested size. </td></tr>
    <tr><td class="paramname">flags</td><td>or'ed flags </td></tr>
    <tr><td class="paramname">shared_user_data_size</td><td>size for a shared data area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the actual size will be rounded up to the next page size. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a new ring buffer or NULL if there was a problem. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#a3bf2613790c34f1da4da7e5d28b9f418" title="create a ring buffer (rather than open and existing one)">QB_RB_FLAG_CREATE</a>, <a class="el" href="qbrb_8h.html#ac1857ecabb97a65d157bbc5ccaa536d9" title="New calls to qb_rb_chunk_write() will call qb_rb_chunk_reclaim() if there is not enough space...">QB_RB_FLAG_OVERWRITE</a>, <a class="el" href="qbrb_8h.html#afdb866bfc44855b73e4404f6526ce5ad" title="The ringbuffer will be shared between pthreads not processes.">QB_RB_FLAG_SHARED_THREAD</a>, <a class="el" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c" title="The ringbuffer will be shared between processes.">QB_RB_FLAG_SHARED_PROCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe1712513305a610df664f0b8a382d95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_refcount_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reference count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of references </dd></dl>

</div>
</div>
<a class="anchor" id="aa18f8ca651e8ef29b43a311e280aee37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* qb_rb_shared_user_data_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a point to user shared data area. </p>
<dl class="section note"><dt>Note</dt><dd>this is of size "shared_user_data_size" passed into <a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to shared data. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e6b26f1c15cbd4050a9487e4399757c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_space_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The amount of free space in the ring buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Some of this space will be consumed by the chunk headers. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3aec2cca1b640d73c35efdcb545225f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_space_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The total amount of data in the buffer. </p>
<dl class="section note"><dt>Note</dt><dd>This includes the chunk headers (8 bytes per chunk). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53a05bc0ced76b97f38be38bfd4ee19f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_write_to_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&#160;</td>
          <td class="paramname"><em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the contents of the Ring Buffer to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>open file to write the ringbuffer data to. </td></tr>
    <tr><td class="paramname">rb</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="qbrb_8h.html#aeaccf9973a435866fcddd937a2ad8f90" title="Load the saved ring buffer from file into tempory memory.">qb_rb_create_from_file()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
