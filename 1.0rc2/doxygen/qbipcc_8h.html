<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libqb: qbipcc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>qbipcc.h File Reference</h1>
<p>Client IPC API.  
<a href="#_details">More...</a></p>
<code>#include &lt;<a class="el" href="qbconfig_8h.html">qb/qbconfig.h</a>&gt;</code><br/>
<code>#include &lt;pthread.h&gt;</code><br/>
<code>#include &lt;sys/poll.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="qbhdb_8h.html">qb/qbhdb.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="qbipc__common_8h.html">qb/qbipc_common.h</a>&gt;</code><br/>
<div class="dynheader">
Include dependency graph for qbipcc.h:</div>
<div class="dynsection">
<div class="center"><img src="qbipcc_8h__incl.png" border="0" usemap="#qbipcc_8h_map" alt=""/></div>
<map name="qbipcc_8h_map" id="qbipcc_8h">
<area shape="rect" id="node3" href="qbconfig_8h.html" title="qb/qbconfig.h" alt="" coords="5,83,115,112"/><area shape="rect" id="node11" href="qbhdb_8h.html" title="The handle database is for reference counting objects." alt="" coords="619,83,712,112"/><area shape="rect" id="node26" href="qbipc__common_8h.html" title="common types and definitions" alt="" coords="337,160,492,189"/><area shape="rect" id="node19" href="qbarray_8h.html" title="This is a dynamic array (it can grow, but without moving memory)." alt="" coords="775,160,876,189"/><area shape="rect" id="node24" href="qbdefs_8h.html" title="qb/qbdefs.h" alt="" coords="887,237,985,267"/></map>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct qb_ipcc_connection&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a3a82d4c6b7a2ab201d992765d0de3a9a">qb_ipcc_connect</a> (const char *name, size_t max_msg_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a connection to an IPC service.  <a href="#a3a82d4c6b7a2ab201d992765d0de3a9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#aa2947e072846820e98123decc416f45e">qb_ipcc_verify_dgram_max_msg_size</a> (size_t max_msg_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test kernel dgram socket buffers to verify the largest size up to the max_msg_size value a single msg can be.  <a href="#aa2947e072846820e98123decc416f45e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a067acfb7767d297df3ff5278ca59a807">qb_ipcc_disconnect</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect an IPC connection.  <a href="#a067acfb7767d297df3ff5278ca59a807"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#aa8bb1166a3262ec66a09baf8d2677e72">qb_ipcc_fd_get</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, int32_t *fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the file descriptor to poll.  <a href="#aa8bb1166a3262ec66a09baf8d2677e72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a989bfc3952a75c144b43bde878ab17ea">qb_ipcc_fc_enable_max_set</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, uint32_t max)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum allowable flowcontrol value.  <a href="#a989bfc3952a75c144b43bde878ab17ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a65e21d1c3d32a193942383df243970ec">qb_ipcc_send</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, const void *msg_ptr, size_t msg_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message.  <a href="#a65e21d1c3d32a193942383df243970ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#ad24320112b230d637c007698610cddf4">qb_ipcc_sendv</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, const struct iovec *iov, size_t iov_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send a message (iovec).  <a href="#ad24320112b230d637c007698610cddf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#aa037f63fbd7104908bba9da4c0835a5b">qb_ipcc_recv</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, void *msg_ptr, size_t msg_len, int32_t ms_timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive a response.  <a href="#aa037f63fbd7104908bba9da4c0835a5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#ad5f6553aa735a1d59f69a952bcdfff33">qb_ipcc_sendv_recv</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, const struct iovec *iov, uint32_t iov_len, void *msg_ptr, size_t msg_len, int32_t ms_timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a convenience function that simply sends and then recvs.  <a href="#ad5f6553aa735a1d59f69a952bcdfff33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a6c5e4b3f7c1db49ad57dc24e04318822">qb_ipcc_event_recv</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, void *msg_ptr, size_t msg_len, int32_t ms_timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive an event.  <a href="#a6c5e4b3f7c1db49ad57dc24e04318822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a4faf27eafed021ac22b10bb96f5ac5e8">qb_ipcc_context_set</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c, void *context)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate a "user" pointer with this connection.  <a href="#a4faf27eafed021ac22b10bb96f5ac5e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#ae21230debda1cadc0cc7b59b3cef50c0">qb_ipcc_context_get</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the context (set previously).  <a href="#ae21230debda1cadc0cc7b59b3cef50c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#af152f628c79fd670e64c852b4db32ca3">qb_ipcc_is_connected</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is the connection connected?  <a href="#af152f628c79fd670e64c852b4db32ca3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbipcc_8h.html#a93ba9cda10fbd1c41f92c4e96f90f769">qb_ipcc_get_buffer_size</a> (<a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *c)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What is the actual buffer size used after the connection.  <a href="#a93ba9cda10fbd1c41f92c4e96f90f769"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Client IPC API. </p>
<dl class="user"><dt><b>Lifecycle of an IPC connection.</b></dt><dd>An IPC connection is made to the server with <a class="el" href="qbipcc_8h.html#a3a82d4c6b7a2ab201d992765d0de3a9a" title="Create a connection to an IPC service.">qb_ipcc_connect()</a>. This function connects to the server and requests channels be created for communication. To disconnect, the client either exits or executes the function <a class="el" href="qbipcc_8h.html#a067acfb7767d297df3ff5278ca59a807" title="Disconnect an IPC connection.">qb_ipcc_disconnect()</a>.</dd></dl>
<dl class="user"><dt><b>Synchronous communication</b></dt><dd>The function <a class="el" href="qbipcc_8h.html#ad5f6553aa735a1d59f69a952bcdfff33" title="This is a convenience function that simply sends and then recvs.">qb_ipcc_sendv_recv()</a> sends an iovector request and receives a response.</dd></dl>
<dl class="user"><dt><b>Asynchronous requests from the client</b></dt><dd>The function <a class="el" href="qbipcc_8h.html#ad24320112b230d637c007698610cddf4" title="Send a message (iovec).">qb_ipcc_sendv()</a> sends an iovector request. The function <a class="el" href="qbipcc_8h.html#a65e21d1c3d32a193942383df243970ec" title="Send a message.">qb_ipcc_send()</a> sends an message buffer request.</dd></dl>
<dl class="user"><dt><b>Asynchronous events from the server</b></dt><dd>The <a class="el" href="qbipcc_8h.html#a6c5e4b3f7c1db49ad57dc24e04318822" title="Receive an event.">qb_ipcc_event_recv()</a> function receives an out-of-band asyncronous message. The asynchronous messages are queued and can provide very high out-of-band performance. To determine when to call <a class="el" href="qbipcc_8h.html#a6c5e4b3f7c1db49ad57dc24e04318822" title="Receive an event.">qb_ipcc_event_recv()</a> the <a class="el" href="qbipcc_8h.html#aa8bb1166a3262ec66a09baf8d2677e72" title="Get the file descriptor to poll.">qb_ipcc_fd_get()</a> call is used to obtain a file descriptor used in the poll() or select() system calls. </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a31c6c3e3172caf492a5612b067d0866b"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_connection_t" ref="a31c6c3e3172caf492a5612b067d0866b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct qb_ipcc_connection <a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a4">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3a82d4c6b7a2ab201d992765d0de3a9a"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_connect" ref="a3a82d4c6b7a2ab201d992765d0de3a9a" args="(const char *name, size_t max_msg_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a>* qb_ipcc_connect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_msg_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a connection to an IPC service. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name of the service. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_msg_size</em>&nbsp;</td><td>biggest msg size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NULL (error: see errno) or a connection object.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is recommended to do a one time check on the max_msg_size value using qb_ipcc_verify_dgram_max_msg_size _BEFORE_ calling the connect function when IPC_SOCKET is in use. Some distributions while allow large message buffers to be set on the socket, but not actually honor them because of kernel state values. The qb_ipcc_verify_dgram_max_msg_size function both sets the socket buffer size and verifies it by doing a send/recv. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a25">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ae21230debda1cadc0cc7b59b3cef50c0"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_context_get" ref="ae21230debda1cadc0cc7b59b3cef50c0" args="(qb_ipcc_connection_t *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* qb_ipcc_context_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the context (set previously). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the context </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbipcc_8h.html#a4faf27eafed021ac22b10bb96f5ac5e8" title="Associate a &quot;user&quot; pointer with this connection.">qb_ipcc_context_set()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4faf27eafed021ac22b10bb96f5ac5e8"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_context_set" ref="a4faf27eafed021ac22b10bb96f5ac5e8" args="(qb_ipcc_connection_t *c, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qb_ipcc_context_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associate a "user" pointer with this connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>context</em>&nbsp;</td><td>the point to associate with this connection. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbipcc_8h.html#ae21230debda1cadc0cc7b59b3cef50c0" title="Get the context (set previously).">qb_ipcc_context_get()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a067acfb7767d297df3ff5278ca59a807"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_disconnect" ref="a067acfb7767d297df3ff5278ca59a807" args="(qb_ipcc_connection_t *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qb_ipcc_disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect an IPC connection. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a27">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6c5e4b3f7c1db49ad57dc24e04318822"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_event_recv" ref="a6c5e4b3f7c1db49ad57dc24e04318822" args="(qb_ipcc_connection_t *c, void *msg_ptr, size_t msg_len, int32_t ms_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_ipcc_event_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>msg_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>ms_timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive an event. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_ptr</em>&nbsp;</td><td>pointer to a message buffer to receive into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_len</em>&nbsp;</td><td>the size of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_timeout</em>&nbsp;</td><td>time in milli seconds to wait for a message 0 == no wait, negative == block, positive == wait X ms. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_timeout</em>&nbsp;</td><td>max time to wait for a response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>size of the message or error (-errno)</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that msg_ptr will include a <a class="el" href="structqb__ipc__response__header.html">qb_ipc_response_header</a> at the top of the message. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a12">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a989bfc3952a75c144b43bde878ab17ea"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_fc_enable_max_set" ref="a989bfc3952a75c144b43bde878ab17ea" args="(qb_ipcc_connection_t *c, uint32_t max)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_ipcc_fc_enable_max_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the maximum allowable flowcontrol value. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>the default is 1</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max</em>&nbsp;</td><td>the max allowable flowcontrol value (1 or 2) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8bb1166a3262ec66a09baf8d2677e72"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_fd_get" ref="aa8bb1166a3262ec66a09baf8d2677e72" args="(qb_ipcc_connection_t *c, int32_t *fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_ipcc_fd_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the file descriptor to poll. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>(out) file descriptor to poll </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93ba9cda10fbd1c41f92c4e96f90f769"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_get_buffer_size" ref="a93ba9cda10fbd1c41f92c4e96f90f769" args="(qb_ipcc_connection_t *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_ipcc_get_buffer_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>What is the actual buffer size used after the connection. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The buffer size is guaranteed to be at least the size of the value given in qb_ipcc_connect, but it is possible the server will enforce a larger size depending on the implementation. If the server side is known to enforce a buffer size, use this function after the client connection is established to retrieve the buffer size in use. It is important for the client side to know the buffer size in use so the client can successfully retrieve large server events.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connection</em>&nbsp;</td><td>size in bytes or -error code </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a26">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="af152f628c79fd670e64c852b4db32ca3"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_is_connected" ref="af152f628c79fd670e64c852b4db32ca3" args="(qb_ipcc_connection_t *c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_ipcc_is_connected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is the connection connected? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>QB_TRUE</em>&nbsp;</td><td>when connected </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>QB_FALSE</em>&nbsp;</td><td>when not connected </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa037f63fbd7104908bba9da4c0835a5b"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_recv" ref="aa037f63fbd7104908bba9da4c0835a5b" args="(qb_ipcc_connection_t *c, void *msg_ptr, size_t msg_len, int32_t ms_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_ipcc_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>msg_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>ms_timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Receive a response. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_ptr</em>&nbsp;</td><td>pointer to a message buffer to receive into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_len</em>&nbsp;</td><td>the size of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_timeout</em>&nbsp;</td><td>max time to wait for a response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(size recv'ed, -errno == error)</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>that msg_ptr will include a <a class="el" href="structqb__ipc__response__header.html">qb_ipc_response_header</a> at the top of the message. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a13">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a65e21d1c3d32a193942383df243970ec"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_send" ref="a65e21d1c3d32a193942383df243970ec" args="(qb_ipcc_connection_t *c, const void *msg_ptr, size_t msg_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_ipcc_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>msg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>msg_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a message. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_ptr</em>&nbsp;</td><td>pointer to a message to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_len</em>&nbsp;</td><td>the size of the message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(size sent, -errno == error)</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>the msg_ptr must include a <a class="el" href="structqb__ipc__request__header.html">qb_ipc_request_header</a> at the top of the message. The server will read the size field to determine how much to recv. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a11">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad24320112b230d637c007698610cddf4"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_sendv" ref="ad24320112b230d637c007698610cddf4" args="(qb_ipcc_connection_t *c, const struct iovec *iov, size_t iov_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_ipcc_sendv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>iov_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send a message (iovec). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov</em>&nbsp;</td><td>pointer to an iovec struct to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov_len</em>&nbsp;</td><td>the number of iovecs used </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>(size sent, -errno == error)</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>the iov[0] must be a <a class="el" href="structqb__ipc__request__header.html">qb_ipc_request_header</a>. The server will read the size field to determine how much to recv. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ipcclient_8c-example.html#a7">ipcclient.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad5f6553aa735a1d59f69a952bcdfff33"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_sendv_recv" ref="ad5f6553aa735a1d59f69a952bcdfff33" args="(qb_ipcc_connection_t *c, const struct iovec *iov, uint32_t iov_len, void *msg_ptr, size_t msg_len, int32_t ms_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_ipcc_sendv_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbipcc_8h.html#a31c6c3e3172caf492a5612b067d0866b">qb_ipcc_connection_t</a> *&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&nbsp;</td>
          <td class="paramname"> <em>iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>iov_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>msg_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>msg_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>ms_timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a convenience function that simply sends and then recvs. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>connection instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov</em>&nbsp;</td><td>pointer to an iovec struct to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iov_len</em>&nbsp;</td><td>the number of iovecs used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_ptr</em>&nbsp;</td><td>pointer to a message buffer to receive into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>msg_len</em>&nbsp;</td><td>the size of the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_timeout</em>&nbsp;</td><td>max time to wait for a response</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>the iov[0] must include a <a class="el" href="structqb__ipc__request__header.html">qb_ipc_request_header</a> at the top of the message. The server will read the size field to determine how much to recv. </dd>
<dd>
that msg_ptr will include a <a class="el" href="structqb__ipc__response__header.html">qb_ipc_response_header</a> at the top of the message.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbipcc_8h.html#ad24320112b230d637c007698610cddf4" title="Send a message (iovec).">qb_ipcc_sendv()</a> <a class="el" href="qbipcc_8h.html#aa037f63fbd7104908bba9da4c0835a5b" title="Receive a response.">qb_ipcc_recv()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2947e072846820e98123decc416f45e"></a><!-- doxytag: member="qbipcc.h::qb_ipcc_verify_dgram_max_msg_size" ref="aa2947e072846820e98123decc416f45e" args="(size_t max_msg_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_ipcc_verify_dgram_max_msg_size </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>max_msg_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test kernel dgram socket buffers to verify the largest size up to the max_msg_size value a single msg can be. </p>
<p>Rounds down to the nearest 1k.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>max_msg_size</em>&nbsp;</td><td>biggest msg size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 if max size can not be detected, positive value representing the largest single msg up to max_msg_size that can successfully be sent over a unix dgram socket. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 2 Feb 2016 for libqb by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
