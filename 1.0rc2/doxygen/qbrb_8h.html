<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>libqb: qbrb.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>qbrb.h File Reference</h1>
<p>This implements a ring buffer that works in "chunks" not bytes.  
<a href="#_details">More...</a></p>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<div class="dynheader">
Include dependency graph for qbrb.h:</div>
<div class="dynsection">
<div class="center"><img src="qbrb_8h__incl.png" border="0" usemap="#qbrb_8h_map" alt=""/></div>
</div>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a3bf2613790c34f1da4da7e5d28b9f418">QB_RB_FLAG_CREATE</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">create a ring buffer (rather than open and existing one)  <a href="#a3bf2613790c34f1da4da7e5d28b9f418"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ac1857ecabb97a65d157bbc5ccaa536d9">QB_RB_FLAG_OVERWRITE</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">New calls to <a class="el" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121" title="Write a chunk to the ring buffer.">qb_rb_chunk_write()</a> will call <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a> if there is not enough space.  <a href="#ac1857ecabb97a65d157bbc5ccaa536d9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#afdb866bfc44855b73e4404f6526ce5ad">QB_RB_FLAG_SHARED_THREAD</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ringbuffer will be shared between pthreads not processes.  <a href="#afdb866bfc44855b73e4404f6526ce5ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c">QB_RB_FLAG_SHARED_PROCESS</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The ringbuffer will be shared between processes.  <a href="#ac893c2640e8291e6229a227a861c760c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a2a9796b3ce0f4ea6fd710697058bb87c">QB_RB_FLAG_NO_SEMAPHORE</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Don't use semaphores, only atomic ops.  <a href="#a2a9796b3ce0f4ea6fd710697058bb87c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct qb_ringbuffer_s&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31">qb_rb_open</a> (const char *name, size_t size, uint32_t flags, size_t shared_user_data_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the ring buffer with the given type.  <a href="#ad7f0ee52204d491ddb6c5adf88e38c31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a676646fa5f7d2dba585a92b99f91a84c">qb_rb_close</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference the ringbuffer and if we are the last user destroy it.  <a href="#a676646fa5f7d2dba585a92b99f91a84c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aedda1312afff053ccbfddbd074351641">qb_rb_name_get</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the name of the ringbuffer.  <a href="#aedda1312afff053ccbfddbd074351641"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aa18f8ca651e8ef29b43a311e280aee37">qb_rb_shared_user_data_get</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a point to user shared data area.  <a href="#aa18f8ca651e8ef29b43a311e280aee37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121">qb_rb_chunk_write</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, const void *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a chunk to the ring buffer.  <a href="#a6be2cb75d70f5befe605501721086121"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c">qb_rb_chunk_alloc</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate space for a chunk of the given size.  <a href="#ae0e73503e8dc50e3cad1022bb740ef6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a0be62e0deea17d91292e2a84f6d864b9">qb_rb_chunk_commit</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">finalize the chunk.  <a href="#a0be62e0deea17d91292e2a84f6d864b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aec633cc7fee08c5c73445fab3edc9d44">qb_rb_chunk_peek</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, void **data_out, int32_t ms_timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read (without reclaiming) the last chunk.  <a href="#aec633cc7fee08c5c73445fab3edc9d44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0">qb_rb_chunk_reclaim</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reclaim the oldest chunk.  <a href="#aea4e369c61625edfad2bda86165725c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aaeb042cad040e561093604ce5050f85b">qb_rb_chunk_read</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, void *data_out, size_t len, int32_t ms_timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the oldest chunk into data_out.  <a href="#aaeb042cad040e561093604ce5050f85b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#abe1712513305a610df664f0b8a382d95">qb_rb_refcount_get</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the reference count.  <a href="#abe1712513305a610df664f0b8a382d95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a0e6b26f1c15cbd4050a9487e4399757c">qb_rb_space_free</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The amount of free space in the ring buffer.  <a href="#a0e6b26f1c15cbd4050a9487e4399757c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a3aec2cca1b640d73c35efdcb545225f9">qb_rb_space_used</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The total amount of data in the buffer.  <a href="#a3aec2cca1b640d73c35efdcb545225f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a961e46671f346f94fefa0690a12a9d71">qb_rb_chunks_used</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The total number of chunks in the buffer.  <a href="#a961e46671f346f94fefa0690a12a9d71"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a53a05bc0ced76b97f38be38bfd4ee19f">qb_rb_write_to_file</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, int32_t fd)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the contents of the Ring Buffer to file.  <a href="#a53a05bc0ced76b97f38be38bfd4ee19f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#aeaccf9973a435866fcddd937a2ad8f90">qb_rb_create_from_file</a> (int32_t fd, uint32_t flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load the saved ring buffer from file into tempory memory.  <a href="#aeaccf9973a435866fcddd937a2ad8f90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a6266e10354c068267cf33ef349ceffb7">qb_rb_chown</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, uid_t owner, gid_t group)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like 'chown' it changes the owner and group of the ringbuffers resources.  <a href="#a6266e10354c068267cf33ef349ceffb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="qbrb_8h.html#a8cb8a90e13ee826b60c93a4b5bbecc64">qb_rb_chmod</a> (<a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *rb, mode_t mode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like 'chmod' it changes the mode of the ringbuffers resources.  <a href="#a8cb8a90e13ee826b60c93a4b5bbecc64"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This implements a ring buffer that works in "chunks" not bytes. </p>
<p>So you write/read a complete chunk or not at all. There are two types of ring buffer normal and overwrite. Overwrite will reclaim the oldest chunks inorder to make way for new ones, the normal version will refuse to write a new chunk if the ring buffer is full.</p>
<p>This implementation is capable of working across processes, but one process must only write and the other prrocess read.</p>
<p>The read process will do the following: </p>
<div class="fragment"><pre class="fragment">        rb = <a class="code" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open</a>(<span class="stringliteral">&quot;test2&quot;</span>, 2000, <a class="code" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c" title="The ringbuffer will be shared between processes.">QB_RB_FLAG_SHARED_PROCESS</a>|<a class="code" href="qbrb_8h.html#a3bf2613790c34f1da4da7e5d28b9f418" title="create a ring buffer (rather than open and existing one)">QB_RB_FLAG_CREATE</a>);
        <span class="keywordflow">for</span> (i = 0; i &lt; 200; i++) {
        try_read_again:
                l = <a class="code" href="qbrb_8h.html#aaeb042cad040e561093604ce5050f85b" title="Read the oldest chunk into data_out.">qb_rb_chunk_read</a>(rb, (<span class="keywordtype">void</span> *)out, 32, 1000);
                <span class="keywordflow">if</span> (l &lt; 0) {
                        <span class="keywordflow">goto</span> try_read_again;
                }
        }
        ...
        <a class="code" href="qbrb_8h.html#a676646fa5f7d2dba585a92b99f91a84c" title="Dereference the ringbuffer and if we are the last user destroy it.">qb_rb_close</a>(rb);
</pre></div><p>The write process will do the following: </p>
<div class="fragment"><pre class="fragment">        rb = <a class="code" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open</a>(<span class="stringliteral">&quot;test2&quot;</span>, 2000, <a class="code" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c" title="The ringbuffer will be shared between processes.">QB_RB_FLAG_SHARED_PROCESS</a>);
        <span class="keywordflow">for</span> (i = 0; i &lt; 200; i++) {
 try_write_again:
                l = <a class="code" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121" title="Write a chunk to the ring buffer.">qb_rb_chunk_write</a>(rb, &amp;v, <span class="keyword">sizeof</span>(v));
                <span class="keywordflow">if</span> (l &lt; <span class="keyword">sizeof</span>(v)) {
                        <span class="keywordflow">goto</span> try_write_again;
                }
        }
        ...
        <a class="code" href="qbrb_8h.html#a676646fa5f7d2dba585a92b99f91a84c" title="Dereference the ringbuffer and if we are the last user destroy it.">qb_rb_close</a>(rb);
</pre></div><dl class="author"><dt><b>Author:</b></dt><dd>Angus Salkeld &lt;<a href="mailto:asalkeld@redhat.com">asalkeld@redhat.com</a>&gt; </dd></dl>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a3bf2613790c34f1da4da7e5d28b9f418"></a><!-- doxytag: member="qbrb.h::QB_RB_FLAG_CREATE" ref="a3bf2613790c34f1da4da7e5d28b9f418" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_CREATE&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>create a ring buffer (rather than open and existing one) </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2a9796b3ce0f4ea6fd710697058bb87c"></a><!-- doxytag: member="qbrb.h::QB_RB_FLAG_NO_SEMAPHORE" ref="a2a9796b3ce0f4ea6fd710697058bb87c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_NO_SEMAPHORE&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Don't use semaphores, only atomic ops. </p>
<p>This mean that the timeout passed into <a class="el" href="qbrb_8h.html#aaeb042cad040e561093604ce5050f85b" title="Read the oldest chunk into data_out.">qb_rb_chunk_read()</a> will be ignored. </p>

</div>
</div>
<a class="anchor" id="ac1857ecabb97a65d157bbc5ccaa536d9"></a><!-- doxytag: member="qbrb.h::QB_RB_FLAG_OVERWRITE" ref="ac1857ecabb97a65d157bbc5ccaa536d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_OVERWRITE&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>New calls to <a class="el" href="qbrb_8h.html#a6be2cb75d70f5befe605501721086121" title="Write a chunk to the ring buffer.">qb_rb_chunk_write()</a> will call <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a> if there is not enough space. </p>
<p>If this is not set then new writes will be refused. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac893c2640e8291e6229a227a861c760c"></a><!-- doxytag: member="qbrb.h::QB_RB_FLAG_SHARED_PROCESS" ref="ac893c2640e8291e6229a227a861c760c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_SHARED_PROCESS&nbsp;&nbsp;&nbsp;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ringbuffer will be shared between processes. </p>
<p>This effects the type of locks/semaphores that are used. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afdb866bfc44855b73e4404f6526ce5ad"></a><!-- doxytag: member="qbrb.h::QB_RB_FLAG_SHARED_THREAD" ref="afdb866bfc44855b73e4404f6526ce5ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QB_RB_FLAG_SHARED_THREAD&nbsp;&nbsp;&nbsp;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The ringbuffer will be shared between pthreads not processes. </p>
<p>This effects the type of locks/semaphores that are used. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa73b885fa2fbda5dfe4f374e4e0ae0da"></a><!-- doxytag: member="qbrb.h::qb_ringbuffer_t" ref="aa73b885fa2fbda5dfe4f374e4e0ae0da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct qb_ringbuffer_s <a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a8cb8a90e13ee826b60c93a4b5bbecc64"></a><!-- doxytag: member="qbrb.h::qb_rb_chmod" ref="a8cb8a90e13ee826b60c93a4b5bbecc64" args="(qb_ringbuffer_t *rb, mode_t mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_chmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like 'chmod' it changes the mode of the ringbuffers resources. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>mode to change to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>== ok </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-errno</em>&nbsp;</td><td>for error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6266e10354c068267cf33ef349ceffb7"></a><!-- doxytag: member="qbrb.h::qb_rb_chown" ref="a6266e10354c068267cf33ef349ceffb7" args="(qb_ringbuffer_t *rb, uid_t owner, gid_t group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_chown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&nbsp;</td>
          <td class="paramname"> <em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&nbsp;</td>
          <td class="paramname"> <em>group</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like 'chown' it changes the owner and group of the ringbuffers resources. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>uid of the owner to change to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>gid of the group to change to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>status (0 = ok, -errno for error) </dd></dl>

</div>
</div>
<a class="anchor" id="ae0e73503e8dc50e3cad1022bb740ef6c"></a><!-- doxytag: member="qbrb.h::qb_rb_chunk_alloc" ref="ae0e73503e8dc50e3cad1022bb740ef6c" args="(qb_ringbuffer_t *rb, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* qb_rb_chunk_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate space for a chunk of the given size. </p>
<p>If type == QB_RB_FLAG_OVERWRITE and NULL is returned, memory corruption of the memory file has occured. The ringbuffer should be destroyed. If type == QB_RB_NORMAL then when there is not enough space it will return NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>(in) the size to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to chunk to write to, or NULL (if no space).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c" title="Allocate space for a chunk of the given size.">qb_rb_chunk_alloc()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0be62e0deea17d91292e2a84f6d864b9"></a><!-- doxytag: member="qbrb.h::qb_rb_chunk_commit" ref="a0be62e0deea17d91292e2a84f6d864b9" args="(qb_ringbuffer_t *rb, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_chunk_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>finalize the chunk. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>(in) the size of the chunk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec633cc7fee08c5c73445fab3edc9d44"></a><!-- doxytag: member="qbrb.h::qb_rb_chunk_peek" ref="aec633cc7fee08c5c73445fab3edc9d44" args="(qb_ringbuffer_t *rb, void **data_out, int32_t ms_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunk_peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>ms_timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read (without reclaiming) the last chunk. </p>
<p>This function is a way of accessing the next chunk without a memcpy(). You can read the chunk data in place.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function will not "pop" the chunk, you will need to call <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a>. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_out</em>&nbsp;</td><td>(out) a pointer to the next chunk to read (not copied). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_timeout</em>&nbsp;</td><td>(in) time to wait for new data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the chunk (0 if buffer empty). </dd></dl>

</div>
</div>
<a class="anchor" id="aaeb042cad040e561093604ce5050f85b"></a><!-- doxytag: member="qbrb.h::qb_rb_chunk_read" ref="aaeb042cad040e561093604ce5050f85b" args="(qb_ringbuffer_t *rb, void *data_out, size_t len, int32_t ms_timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunk_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>data_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>ms_timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read the oldest chunk into data_out. </p>
<p>This is the same as <a class="el" href="qbrb_8h.html#aec633cc7fee08c5c73445fab3edc9d44" title="Read (without reclaiming) the last chunk.">qb_rb_chunk_peek()</a> memcpy() and <a class="el" href="qbrb_8h.html#aea4e369c61625edfad2bda86165725c0" title="Reclaim the oldest chunk.">qb_rb_chunk_reclaim()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data_out</em>&nbsp;</td><td>(in/out) the chunk will be memcpy'ed into this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>(in) the size of data_out. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_timeout</em>&nbsp;</td><td>the amount od time to wait for new data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the size of the chunk, or error. </dd></dl>

</div>
</div>
<a class="anchor" id="aea4e369c61625edfad2bda86165725c0"></a><!-- doxytag: member="qbrb.h::qb_rb_chunk_reclaim" ref="aea4e369c61625edfad2bda86165725c0" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qb_rb_chunk_reclaim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reclaim the oldest chunk. </p>
<p>You will need to call this if using <a class="el" href="qbrb_8h.html#aec633cc7fee08c5c73445fab3edc9d44" title="Read (without reclaiming) the last chunk.">qb_rb_chunk_peek()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6be2cb75d70f5befe605501721086121"></a><!-- doxytag: member="qbrb.h::qb_rb_chunk_write" ref="a6be2cb75d70f5befe605501721086121" args="(qb_ringbuffer_t *rb, const void *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunk_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a chunk to the ring buffer. </p>
<p>This simply calls <a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c" title="Allocate space for a chunk of the given size.">qb_rb_chunk_alloc()</a> and then <a class="el" href="qbrb_8h.html#a0be62e0deea17d91292e2a84f6d864b9" title="finalize the chunk.">qb_rb_chunk_commit()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>(in) the data to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>(in) the size of the chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of bytes actually buffered (either len or -1).</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#ae0e73503e8dc50e3cad1022bb740ef6c" title="Allocate space for a chunk of the given size.">qb_rb_chunk_alloc()</a> </dd>
<dd>
<a class="el" href="qbrb_8h.html#a0be62e0deea17d91292e2a84f6d864b9" title="finalize the chunk.">qb_rb_chunk_commit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a961e46671f346f94fefa0690a12a9d71"></a><!-- doxytag: member="qbrb.h::qb_rb_chunks_used" ref="a961e46671f346f94fefa0690a12a9d71" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_chunks_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The total number of chunks in the buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a676646fa5f7d2dba585a92b99f91a84c"></a><!-- doxytag: member="qbrb.h::qb_rb_close" ref="a676646fa5f7d2dba585a92b99f91a84c" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qb_rb_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereference the ringbuffer and if we are the last user destroy it. </p>
<p>All files, mmaped memory, semaphores and locks will be destroyed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeaccf9973a435866fcddd937a2ad8f90"></a><!-- doxytag: member="qbrb.h::qb_rb_create_from_file" ref="aeaccf9973a435866fcddd937a2ad8f90" args="(int32_t fd, uint32_t flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a>* qb_rb_create_from_file </td>
          <td>(</td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Load the saved ring buffer from file into tempory memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>file with saved ringbuffer data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>same flags as passed into <a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new ringbuffer instance </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#a53a05bc0ced76b97f38be38bfd4ee19f" title="Write the contents of the Ring Buffer to file.">qb_rb_write_to_file()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aedda1312afff053ccbfddbd074351641"></a><!-- doxytag: member="qbrb.h::qb_rb_name_get" ref="aedda1312afff053ccbfddbd074351641" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* qb_rb_name_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the name of the ringbuffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>name. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7f0ee52204d491ddb6c5adf88e38c31"></a><!-- doxytag: member="qbrb.h::qb_rb_open" ref="ad7f0ee52204d491ddb6c5adf88e38c31" args="(const char *name, size_t size, uint32_t flags, size_t shared_user_data_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a>* qb_rb_open </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>shared_user_data_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create the ring buffer with the given type. </p>
<p>This creates allocates a ring buffer in shared memory.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the unique name of this ringbuffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>the requested size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>or'ed flags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shared_user_data_size</em>&nbsp;</td><td>size for a shared data area. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>the actual size will be rounded up to the next page size. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new ring buffer or NULL if there was a problem. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#a3bf2613790c34f1da4da7e5d28b9f418" title="create a ring buffer (rather than open and existing one)">QB_RB_FLAG_CREATE</a>, <a class="el" href="qbrb_8h.html#ac1857ecabb97a65d157bbc5ccaa536d9" title="New calls to qb_rb_chunk_write() will call qb_rb_chunk_reclaim() if there is not...">QB_RB_FLAG_OVERWRITE</a>, <a class="el" href="qbrb_8h.html#afdb866bfc44855b73e4404f6526ce5ad" title="The ringbuffer will be shared between pthreads not processes.">QB_RB_FLAG_SHARED_THREAD</a>, <a class="el" href="qbrb_8h.html#ac893c2640e8291e6229a227a861c760c" title="The ringbuffer will be shared between processes.">QB_RB_FLAG_SHARED_PROCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe1712513305a610df664f0b8a382d95"></a><!-- doxytag: member="qbrb.h::qb_rb_refcount_get" ref="abe1712513305a610df664f0b8a382d95" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t qb_rb_refcount_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the reference count. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of references </dd></dl>

</div>
</div>
<a class="anchor" id="aa18f8ca651e8ef29b43a311e280aee37"></a><!-- doxytag: member="qbrb.h::qb_rb_shared_user_data_get" ref="aa18f8ca651e8ef29b43a311e280aee37" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* qb_rb_shared_user_data_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a point to user shared data area. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>this is of size "shared_user_data_size" passed into <a class="el" href="qbrb_8h.html#ad7f0ee52204d491ddb6c5adf88e38c31" title="Create the ring buffer with the given type.">qb_rb_open()</a></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to shared data. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e6b26f1c15cbd4050a9487e4399757c"></a><!-- doxytag: member="qbrb.h::qb_rb_space_free" ref="a0e6b26f1c15cbd4050a9487e4399757c" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_space_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The amount of free space in the ring buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Some of this space will be consumed by the chunk headers. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3aec2cca1b640d73c35efdcb545225f9"></a><!-- doxytag: member="qbrb.h::qb_rb_space_used" ref="a3aec2cca1b640d73c35efdcb545225f9" args="(qb_ringbuffer_t *rb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_space_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The total amount of data in the buffer. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This includes the chunk headers (8 bytes per chunk). </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a53a05bc0ced76b97f38be38bfd4ee19f"></a><!-- doxytag: member="qbrb.h::qb_rb_write_to_file" ref="a53a05bc0ced76b97f38be38bfd4ee19f" args="(qb_ringbuffer_t *rb, int32_t fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t qb_rb_write_to_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qbrb_8h.html#aa73b885fa2fbda5dfe4f374e4e0ae0da">qb_ringbuffer_t</a> *&nbsp;</td>
          <td class="paramname"> <em>rb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>fd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write the contents of the Ring Buffer to file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>open file to write the ringbuffer data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rb</em>&nbsp;</td><td>ringbuffer instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qbrb_8h.html#aeaccf9973a435866fcddd937a2ad8f90" title="Load the saved ring buffer from file into tempory memory.">qb_rb_create_from_file()</a> </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr size="1"/><address style="text-align: right;"><small>Generated on 2 Feb 2016 for libqb by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
